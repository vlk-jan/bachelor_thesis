\section{Comparison and chosen approach}
    We can use several design approaches to solve the task of crossing a street. We will briefly present them and state a few advantages and disadvantages of each one. We will mainly use the informations and insights from \cite{BT_intro}.\\\\
    \bfc{Monolithic approach}\\
        We can use a monolithic approach, where we write a single program that will handle all the tasks.\\
        This approach is the most straightforward and easiest to implement but is not very flexible. It would be complicated to modify or extend the abilities of our program to the point where we would be forced to rewrite it in its entirety. This approach also generates a design that is not easily readable, and it would be almost impossible to find and correct bugs and glitches.\\
        For all those reasons, the monolithic approach is unsuitable for anything other than elementary systems, and we will not use it for our solution.\\\\
    \bfc{FSM approach}\\
        The second approach is to use an FSM. More specifically, HFSM as it is an improvement over FSM and addresses a few of the FSM issues.\\
        The advantages of HFSMs are that the structure is intuitive and generally easy to understand. Being common in many parts of computer science and used for quite some time, they are also easy to implement. FSMs also offer good flexibility and maintainability for many problems.\\
        The main disadvantage of HFSMs is that the flexibility is limited to certain areas of use and systems with limited scale. It is impossible to add new states or transitions in complex systems easily.\\
        The scalability of FSMs is also a problem. With rising demands on agent AI complexity, game programmers found that the FSMs that they used scaled poorly and were difficult to extend, adapt and reuse.\cite{BT_survey}\\
        The FSM's poor scalability makes this approach unsuitable for our solution.\\\\
    \bfc{BT approach}\\
        The third approach is to design the algorithm in the form of a BT.\\
        The advantages of this approach are its modularity, reusability, reactivity, readability, and scalability. Modularity is closely linked with reusability. The design principles of BTs allow us to decompose the algorithm into sub-trees which may be implemented and tested separately. Decomposition also allows us to tackle large complex systems with relative ease. The BTs are reactive in the sense that they can react quickly and effectively to the changing environment. Even though they require a different design approach than FSMs, they provide a coherent and compact structure that is easy to understand and maintain.\\
        The main disadvantage of BTs is that they are not very common in the industry and are not as well known as FSMs. For this reason, the tools and libraries are not as numerous or mature as those available for FSMs. As mentioned earlier, they are different from FSMs and, as such, require a different approach to designing an optimal solution.\\\\
    \bfc{Chosen approach}\\
        The approach we have chosen to use in this thesis is the BT approach. We have chosen it for many reasons, mainly its scalability, readability, and maintainability of large complex systems. The BTs are also very flexible and can be easily extended and modified. The supervisor also suggested the use of the BT approach.